<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Three.js Human Skeleton from CSV</title>
    <style>
      body {
        margin: 0;
        background: black;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <script>
      const w = 1200,
        h = 700;
      let scene = new THREE.Scene();
      let camera = new THREE.OrthographicCamera(0, w, h, 0, -500, 500);
      let renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(w, h);
      document.body.appendChild(renderer.domElement);

      let frames = {};
      let currentFrame = 1,
        nFrames = 0;
      let scaleFactor = 1;

      // === Real MediaPipe Connections ===
      const faceConnections = [
        [10, 338],
        [338, 297],
        [297, 332],
        [332, 284],
        [284, 251],
        [251, 389],
        [389, 356],
        [356, 454],
        [454, 323],
        [323, 361],
        [361, 288],
        [288, 397],
        [397, 365],
        [365, 379],
        [379, 378],
        [378, 400],
        [400, 377],
        [377, 152],
        [152, 148],
        [148, 176],
        [176, 149],
        [149, 150],
        [150, 136],
        [136, 172],
        [172, 58],
        [58, 132],
        [132, 93],
        [93, 234],
        [234, 127],
        [127, 162],
        [162, 21],
      ];
      const handConnections = [
        [0, 1],
        [1, 2],
        [2, 3],
        [3, 4],
        [0, 5],
        [5, 6],
        [6, 7],
        [7, 8],
        [5, 9],
        [9, 10],
        [10, 11],
        [11, 12],
        [9, 13],
        [13, 14],
        [14, 15],
        [15, 16],
        [13, 17],
        [17, 18],
        [18, 19],
        [19, 20],
      ];
      const poseConnections = [
        [11, 13],
        [13, 15],
        [12, 14],
        [14, 16],
        [11, 12],
        [23, 24],
        [23, 25],
        [24, 26],
        [25, 27],
        [27, 29],
        [26, 28],
        [28, 30],
      ];

      // === Load CSV ===
      Papa.parse("india.csv", {
        download: true,
        header: true,
        dynamicTyping: true,
        complete: function (results) {
          let data = results.data.filter((row) => row.frame && row.x && row.y);
          data.forEach((row) => {
            if (!frames[row.frame]) frames[row.frame] = [];
            frames[row.frame].push(row);
          });
          nFrames = Math.max(...Object.keys(frames).map((f) => parseInt(f)));
          animate();
        },
      });

      function drawFrame(frameData) {
        while (scene.children.length > 0) scene.remove(scene.children[0]);

        let all_xs = frameData.map((p) => p.x * w);
        let all_ys = frameData.map((p) => p.y * h);
        let cx = all_xs.reduce((a, b) => a + b) / all_xs.length;
        let cy = all_ys.reduce((a, b) => a + b) / all_ys.length;

        function drawPart(partData, connections, colorHex) {
          if (!partData.length) return;
          let pointsDict = {};

          partData.forEach((p) => {
            let x = p.x * w;
            let y = p.y * h;
            let xScaled = cx + (x - cx) * scaleFactor;
            let yScaled = cy + (y - cy) * scaleFactor;
            pointsDict[p.index] = new THREE.Vector3(xScaled, h - yScaled, 0);
          });

          // Points
          let pointGeometry = new THREE.BufferGeometry().setFromPoints(
            Object.values(pointsDict)
          );
          let pointMaterial = new THREE.PointsMaterial({
            color: colorHex,
            size: 3,
          });
          scene.add(new THREE.Points(pointGeometry, pointMaterial));

          // Lines
          let linePoints = [];
          connections.forEach(([s, e]) => {
            if (pointsDict[s] && pointsDict[e]) {
              linePoints.push(pointsDict[s], pointsDict[e]);
            }
          });
          if (linePoints.length > 0) {
            let lineGeometry = new THREE.BufferGeometry().setFromPoints(
              linePoints
            );
            let lineMaterial = new THREE.LineBasicMaterial({ color: colorHex });
            scene.add(new THREE.LineSegments(lineGeometry, lineMaterial));
          }
        }

        drawPart(
          frameData.filter((p) => p.part === "face"),
          faceConnections,
          0x00ff00
        );
        drawPart(
          frameData.filter((p) => p.part === "hand" && p.hand_index === 0),
          handConnections,
          0xff0000
        );
        drawPart(
          frameData.filter((p) => p.part === "hand" && p.hand_index === 1),
          handConnections,
          0xff0000
        );
        drawPart(
          frameData.filter((p) => p.part === "pose"),
          poseConnections,
          0x0000ff
        );
      }

      let speed = 2; // Higher = faster, Lower = slower
      let frameCounter = 0;

      function animate() {
        frameCounter++;

        if (frameCounter >= speed) {
          frameCounter = 0; // reset
          if (frames[currentFrame]) {
            drawFrame(frames[currentFrame]);
          }
          currentFrame++;
          if (currentFrame > nFrames) currentFrame = 1;
        }

        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }
    </script>
  </body>
</html>
